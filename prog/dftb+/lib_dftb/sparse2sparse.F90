!--------------------------------------------------------------------------------------------------!
!  DFTB+: general package for performing fast atomistic simulations                                !
!  Copyright (C) 2018  DFTB+ developers group                                                      !
!                                                                                                  !
!  See the LICENSE file for terms of usage and distribution.                                       !
!--------------------------------------------------------------------------------------------------!

#:include 'common.fypp'

!> Contains subroutines for packing/unpacking Hamiltonian-like matrices between the DFTB+ compressed
!> block sparse representation and distributed CSR/CSC matrices
module sparse2sparse
  use assert
  use accuracy
  use constants, only : pi, imag
  use commontypes
  use environment
  use commontypes
  use solvers
  use message
#:if WITH_MPI
  use mpifx
#:endif
#:if WITH_ELSI
  use elsi
#:endif
  implicit none

  private
  public :: TSparse2Sparse, indexFor2Component
#:if WITH_ELSI
  public :: initSparse2Sparse
  public :: calcDensityRealElsi, getEDensityRealElsi
  public :: calcDensityComplexElsi, getEDensityComplexElsi
#:endif

  !> data type for indexing transformation from DFTB+ compressed block to CSR
  type :: TSparse2Sparse

  #:if WITH_ELSI

    logical :: tInit = .false.

    !> number of non-zero matrix elements on this processor
    integer :: nnzLocal

    !>  numberof non-zero matrix elements in the whole sparse matrix
    integer :: nnzGlobal

    !> On which column does this processor start its matrix
    integer :: colStartLocal

    !> On which column does this processor end its matrix
    integer :: colEndLocal

    !> Number of local columns on this processor
    integer :: numColLocal

    !> Local column pointer in the CSC format on this processor
    integer, allocatable :: colPtrLocal(:)

    !> Index for starting row of blocks in nzValLocal
    integer, allocatable :: blockRow(:,:)

    !> Local row index for non-zero elements
    integer, allocatable :: rowIndLocal(:)

    !> List of atoms with elements in the columns held locally
    integer, allocatable :: atomsInColumns(:)

    !> Count of the atoms with elements in the columns held locally
    integer :: nAtomsInColumns

  #:endif

  end type TSparse2Sparse

#:if WITH_ELSI

#:set FLAVOURS = [('real'), ('complex')]

  interface addBlock2Elsi
  #:for SUFFIX in FLAVOURS
    module procedure addBlock2Elsi${SUFFIX}$
  #:endfor
  end interface addBlock2Elsi

  interface cpElsi2Block
  #:for SUFFIX in FLAVOURS
    module procedure cpElsi2Block${SUFFIX}$
  #:endfor
  end interface cpElsi2Block

#:endif

contains

  !> Generate indexing arrays for 2 component blocks, containing 2x2 elements
  subroutine indexFor2Component(iBlockStart, iSparseBlockStart, iAtomStart, iSparseStart,&
      & nNeighbourSK)

    !> Atom offset for the squared matrix
    integer, intent(out) :: iBlockStart(:)

    !> indexing array for the sparse Hamiltonian
    integer, intent(out) :: iSparseBlockStart(0:,:)

    !> Atom offset for the squared matrix
    integer, intent(in) :: iAtomStart(:)

    !> indexing array for the sparse Hamiltonian
    integer, intent(in) :: iSparseStart(0:,:)

    !> Nr. of neighbours for the atoms.
    integer, intent(in) :: nNeighbourSK(:)

    integer :: iAt, nAt, iOrb, iNeigh, iOld

    nAt = size(nNeighbourSK)

    iBlockStart = 0
    iSparseBlockStart = 0

    iBlockStart(1) = iAtomStart(1)
    do iAt = 1, nAt
      iOrb = iAtomStart(iAt + 1) - iAtomStart(iAt) - 1
      iOrb = 2 * iOrb
      iBlockStart(iAt + 1) = iBlockStart(iAt) + iOrb
    end do

    iOld = 0
    do iAt = 1, nAt
      iSparseBlockStart(0,iAt) = iOld
      do iNeigh = 1, nNeighbourSK(iAt)
        iSparseBlockStart(iNeigh,iAt) = iSparseBlockStart(iNeigh-1,iAt)&
            & + 4 * (iSparseStart(iNeigh,iAt) - iSparseStart(iNeigh-1,iAt))
      end do
      iOld = iSparseBlockStart(nNeighbourSK(nAt),iAt)
    end do

  end subroutine indexFor2Component


  !> Convert 2 component spin channels to a single complex block structure
  subroutine pack2ComponentBlock(ham2Component, over2Component, ham, over, iSparseStart,&
      & nNeighbourSK, iHam)

    !> 2 component hamiltonian in sparse storage
    complex(dp), intent(out) :: ham2Component(:)

    !> 2 component overlap matrix in sparse storage
    complex(dp), intent(out) :: over2Component(:)

    !> hamiltonian in sparse storage
    real(dp), intent(in) :: ham(:,:)

    !> overlap matrix in sparse storage
    real(dp), intent(in) :: over(:)

    !> indexing array for the sparse Hamiltonian
    integer, intent(in) :: iSparseStart(0:,:)

    !> Nr. of neighbours for the atoms.
    integer, intent(in) :: nNeighbourSK(:)

    !> Imaginary part of the hamiltonian matrix in sparse storage
    real(dp), intent(in), optional :: iHam(:,:)

    integer :: iOld, iNew, iOrb, iAt, nAt, iNeigh

    @:ASSERT(size(over2Component) == 4 * size(over))
    @:ASSERT(size(ham2Component) == size(ham))

    iOld = 1
    iNew = 1
    do iAt = 1, nAt
      do iNeigh = 1, nNeighbourSK(iAt)
        iOrb = iSparseStart(iNeigh,iAt) - iSparseStart(iNeigh-1,iAt)
        over2Component(iNew:iNew+iOrb-1) = over(iOld:iOld+iOrb-1)
        over2Component(iNew+3*iOrb:iNew+4*iOrb-1) = over(iOld:iOld+iOrb-1)
        ham2Component(iNew:iNew+iOrb-1) = ham(iOld:iOld+iOrb-1,1)+ham(iOld:iOld+iOrb-1,4)
        ham2Component(iNew+3*iOrb:iNew+4*iOrb-1) = ham(iOld:iOld+iOrb-1,1)-ham(iOld:iOld+iOrb-1,4)
        ham2Component(iNew+iOrb:iNew+2*iOrb-1) = ham(iOld:iOld+iOrb-1,2)&
            & + imag * ham(iOld:iOld+iOrb-1,3)
        ham2Component(iNew+2*iOrb:iNew+3*iOrb-1) = ham(iOld:iOld+iOrb-1,2)&
            & - imag * ham(iOld:iOld+iOrb-1,3)
        iOld = iOld + iOrb
        iNew = iNew + 4 * iOrb
      end do
    end do

    if (present(iHam)) then
      iOld = 1
      iNew = 1
      do iAt = 1, nAt
        do iNeigh = 1, nNeighbourSK(iAt)
          iOrb = iSparseStart(iNeigh,iAt) - iSparseStart(iNeigh-1,iAt)
          ham2Component(iNew:iNew+iOrb-1) = imag * (ham(iOld:iOld+iOrb-1,1)+ham(iOld:iOld+iOrb-1,4))
          ham2Component(iNew+3*iOrb:iNew+4*iOrb-1) = imag *&
              & (ham(iOld:iOld+iOrb-1,1)-ham(iOld:iOld+iOrb-1,4))
          ham2Component(iNew+iOrb:iNew+2*iOrb-1) = imag * ham(iOld:iOld+iOrb-1,2)&
              & - ham(iOld:iOld+iOrb-1,3)
          ham2Component(iNew+2*iOrb:iNew+3*iOrb-1) = imag * ham(iOld:iOld+iOrb-1,2)&
              & + ham(iOld:iOld+iOrb-1,3)
          iOld = iOld + iOrb
          iNew = iNew + 4 * iOrb
        end do
      end do
    end if

  end subroutine pack2ComponentBlock


  !> Convert single complex block structure to 2 component spin channels
  subroutine unpack2ComponentBlock(ham2Component, ham, iSparseStart, nNeighbourSK, iHam)

    !> 2 component hamiltonian in sparse storage
    complex(dp), intent(in) :: ham2Component(:)

    !> hamiltonian in sparse storage
    real(dp), intent(out) :: ham(:,:)

    !> indexing array for the sparse Hamiltonian
    integer, intent(in) :: iSparseStart(0:,:)

    !> Nr. of neighbours for the atoms.
    integer, intent(in) :: nNeighbourSK(:)

    !> overlap matrix in sparse storage
    real(dp), intent(out), optional :: iHam(:,:)

    integer :: iOld, iNew, iOrb, iAt, nAt, iNeigh

    @:ASSERT(size(over2Component) = 4 * size(over))
    @:ASSERT(size(ham2Component) = size(ham))

    ham = 0.0_dp
    iOld = 1
    iNew = 1
    do iAt = 1, nAt
      do iNeigh = 1, nNeighbourSK(iAt)
        iOrb = iSparseStart(iNeigh,iAt) - iSparseStart(iNeigh-1,iAt)
        ham(iOld:iOld+iOrb-1,1) = 0.5_dp * real(ham2Component(iNew:iNew+iOrb-1)&
            & + ham2Component(iNew+3*iOrb:iNew+4*iOrb-1))
        ham(iOld:iOld+iOrb-1,2) = 0.5_dp * real(ham2Component(iNew+1*iOrb:iNew+2*iOrb-1)&
            & + conjg(ham2Component(iNew+2*iOrb:iNew+3*iOrb-1)))
        ham(iOld:iOld+iOrb-1,3) = 0.5_dp * aimag(ham2Component(iNew+1*iOrb:iNew+2*iOrb-1)&
            & + conjg(ham2Component(iNew+2*iOrb:iNew+3*iOrb-1)))
        ham(iOld:iOld+iOrb-1,4) = 0.5_dp * real(ham2Component(iNew:iNew+iOrb-1)&
            & - ham2Component(iNew+3*iOrb:iNew+4*iOrb-1))
        iOld = iOld + iOrb
        iNew = iNew + 4 * iOrb
      end do
    end do

    if (present(iHam)) then
      iHam = 0.0_dp
      iOld = 1
      iNew = 1
      do iAt = 1, nAt
        do iNeigh = 1, nNeighbourSK(iAt)
          iOrb = iSparseStart(iNeigh,iAt) - iSparseStart(iNeigh-1,iAt)
          iHam(iOld:iOld+iOrb-1,1) = 0.5_dp * aimag(ham2Component(iNew:iNew+iOrb-1)&
              & + ham2Component(iNew+3*iOrb:iNew+4*iOrb-1))
          iHam(iOld:iOld+iOrb-1,2) = 0.5_dp * aimag(ham2Component(iNew+1*iOrb:iNew+2*iOrb-1)&
              & - conjg(ham2Component(iNew+2*iOrb:iNew+3*iOrb-1)))
          iHam(iOld:iOld+iOrb-1,3) = 0.5_dp * real(ham2Component(iNew+1*iOrb:iNew+2*iOrb-1)&
              & - conjg(ham2Component(iNew+2*iOrb:iNew+3*iOrb-1)))
          iHam(iOld:iOld+iOrb-1,4) = 0.5_dp * aimag(ham2Component(iNew:iNew+iOrb-1)&
              & - ham2Component(iNew+3*iOrb:iNew+4*iOrb-1))
          iOld = iOld + iOrb
          iNew = iNew + 4 * iOrb
        end do
      end do
    end if

  end subroutine unpack2ComponentBlock


#:if WITH_ELSI


  subroutine initSparse2Sparse(self, env, electronicSolver, iNeighbour, nNeighbourSK, iAtomStart,&
      & iSparseStart, img2CentCell)

    !> Sparse conversion instance
    type(TSparse2Sparse), intent(inout) :: self

    !> Environment settings
    type(TEnvironment), intent(in) :: env

    !> Electronic solver information
    type(TElectronicSolver), intent(inout) :: electronicSolver

    !> Neighbour list for the atoms (First index from 0!)
    integer, intent(in) :: iNeighbour(0:,:)

    !> Nr. of neighbours for the atoms.
    integer, intent(in) :: nNeighbourSK(:)

    !> Atom offset for the squared matrix
    integer, intent(in) :: iAtomStart(:)

    !> indexing array for the sparse Hamiltonian
    integer, intent(in) :: iSparseStart(0:,:)

    !> Mapping between image atoms and corresponding atom in the central cell.
    integer, intent(in) :: img2CentCell(:)

    integer :: numCol, iAtom1, iAtom2, iAtom2f, nAtom, ii, jj, iNeigh, iNext, nOrb1, nOrb2
    integer :: iOrig
    integer, allocatable :: blockList(:,:)
    logical, allocatable :: tRowTrans(:)

    if (self%tInit) then
      ! this has been called before, clean out the storage
      deallocate(self%colPtrLocal)
      deallocate(self%rowIndLocal)
      deallocate(self%blockRow)
      deallocate(self%atomsInColumns)
    end if

    numCol = electronicSolver%ELSI_n_basis

    self%colStartLocal = env%mpi%groupComm%rank * electronicSolver%ELSI_CSR_blockSize + 1
    if (env%mpi%groupComm%rank /= env%mpi%groupComm%size - 1) then
      self%numColLocal = electronicSolver%ELSI_CSR_blockSize
    else
      self%numColLocal = numCol - (env%mpi%groupComm%size - 1) * electronicSolver%ELSI_CSR_blockSize
    end if
    self%colEndLocal = self%colStartLocal + self%numColLocal - 1

    allocate(self%colPtrLocal(self%numColLocal + 1))

    call pack2colptr_parallel(iNeighbour, nNeighbourSK, iAtomStart, iSparseStart, img2CentCell,&
        & self%colStartLocal, self%colEndLocal, self%nnzLocal, self%colPtrLocal)

    self%nnzGlobal = 0
    call mpifx_allreduce(env%mpi%groupComm, self%nnzLocal, self%nnzGlobal, MPI_SUM)

    nAtom = size(nNeighbourSK)

    allocate(self%blockRow(0:size(iNeighbour,dim=1)-1,nAtom))
    self%blockRow(:,:) = 0

    allocate(self%atomsInColumns(nAtom))
    self%atomsInColumns(nAtom) = 0
    self%nAtomsInColumns = 0

    allocate(blockList(nAtom,2))
    allocate(tRowTrans(nAtom))
    blockList = 0

    ! Offset in column belonging to transposed triangle
    blockList(:,2) = 1

    do iAtom1 = 1, nAtom
      ii = iAtomStart(iAtom1)
      nOrb1 = iAtomStart(iAtom1+1) - ii
      ! Offset in current column
      blockList(:,1) = 0
      tRowTrans = .false.
      ! Starting index for column in DFTB+ sparse structure, because column probaly already contains
      ! blocks coming from transposing previously processed elements.
      iNext = blockList(iAtom1, 2)
      do iNeigh = 0, nNeighbourSK(iAtom1)
        iOrig = iSparseStart(iNeigh,iAtom1) + 1
        iAtom2 = iNeighbour(iNeigh, iAtom1)
        iAtom2f = img2CentCell(iAtom2)

        jj = iAtomStart(iAtom2f)
        nOrb2 = iAtomStart(iAtom2f+1) - jj

        if (blockList(iAtom2f,1) == 0) then
          blockList(iAtom2f,1) = iNext
          iNext = iNext + nOrb2
        end if

        self%blockRow(iNeigh, iAtom1) = blockList(iAtom2f,1)

        if ( .not. isBlockInLocal(jj,jj+nOrb2-1, ii, ii+nOrb1-1, self%colStartLocal,&
            & self%colEndLocal)) then
          cycle
        end if

        if (iAtom1 /= self%atomsInColumns(max(self%nAtomsInColumns,1))) then
          ! this atom is required for the local columns
          self%nAtomsInColumns = self%nAtomsInColumns + 1
          self%atomsInColumns(self%nAtomsInColumns) = iAtom1
        end if

        if (ii == jj) then
          ! on the diagonal, can not be in other triangle
          cycle
        end if

        ! Because of folding of periodic images, it can happen that the transposed block has already
        ! been registered.
        if (.not. tRowTrans(iAtom2f)) then
          blockList(iAtom2f,2) = blockList(iAtom2f,2) + nOrb1
          tRowTrans(iAtom2f) = .true.
        end if

      end do
    end do

    self%tInit = .true.

  end subroutine initSparse2Sparse


  !> Calculates density matrix using the elsi routine.
  subroutine calcDensityRealElsi(self, parallelKS, electronicSolver, ham, over,&
      & iNeighbour, nNeighbourSK, iAtomStart, iSparseStart, img2CentCell, orb, rho, Eband)

    !> Sparse conversion instance
    type(TSparse2Sparse), intent(inout) :: self

    !> Contains (iK, iS) tuples to be processed in parallel by various processor groups
    type(TParallelKS), intent(in) :: parallelKS

    !> Electronic solver information
    type(TElectronicSolver), intent(inout) :: electronicSolver

    !> hamiltonian in sparse storage
    real(dp), intent(in) :: ham(:,:)

    !> overlap matrix in sparse storage
    real(dp), intent(in) :: over(:)

    !> Neighbour list for the atoms (First index from 0!)
    integer, intent(in) :: iNeighbour(0:,:)

    !> Nr. of neighbours for the atoms.
    integer, intent(in) :: nNeighbourSK(:)

    !> Atom offset for the squared matrix
    integer, intent(in) :: iAtomStart(:)

    !> indexing array for the sparse Hamiltonian
    integer, intent(in) :: iSparseStart(0:,:)

    !> Mapping between image atoms and corresponding atom in the central cell.
    integer, intent(in) :: img2CentCell(:)

    !> data structure with atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Density matrix in DFTB+ sparse format
    real(dp), intent(out) :: rho(:,:)

    !> Band energy
    real(dp), intent(out) :: Eband(:)

    integer :: iS

    real(dp), allocatable :: HnzValLocal(:), SnzValLocal(:)
    real(dp), allocatable :: DMnzValLocal(:)
    logical :: tFirstCall

    tFirstCall = .false.
    if (.not. allocated(self%rowIndLocal)) then
      allocate(self%rowIndLocal(self%nnzLocal))
      tFirstCall = .true.
    end if

    allocate(HnzValLocal(self%nnzLocal))
    allocate(SnzValLocal(self%nnzLocal))
    allocate(DMnzValLocal(self%nnzLocal))

    if (tFirstCall) then
      ! also generate rowIndLocal for the new structure
      call pack2elsi_real(self, over, iNeighbour, nNeighbourSK, iAtomStart, iSparseStart,&
          & img2CentCell, self%colStartLocal, self%colEndLocal, self%colPtrLocal, SnzValLocal,&
          & self%rowIndLocal)
      call elsi_set_csc(electronicSolver%elsiHandle, self%nnzGlobal, self%nnzLocal,&
          & self%numColLocal, self%rowIndLocal, self%colPtrLocal)
    else
      call pack2elsi_real(self, over, iNeighbour, nNeighbourSK, iAtomStart, iSparseStart,&
          & img2CentCell, self%colStartLocal, self%colEndLocal, self%colPtrLocal, SnzValLocal)
    end if

    iS = parallelKS%localKS(2, 1)
    call pack2elsi_real(self, ham(:,iS), iNeighbour, nNeighbourSK, iAtomStart,&
        & iSparseStart, img2CentCell, self%colStartLocal, self%colEndLocal, self%colPtrLocal,&
        & HnzValLocal)

    if (electronicSolver%ELSI_tWriteHS) then
      ! set up for sparse matrix writing
      call elsi_set_rw_csc(electronicSolver%ELSI_rwHandle, self%nnzGlobal, self%nnzLocal,&
          & self%numColLocal)

      call elsi_write_mat_real_sparse(electronicSolver%ELSI_rwHandle, "ELSI_HrealSparse.bin",&
          & self%rowIndLocal, self%colPtrLocal, HnzValLocal)
      call elsi_write_mat_real_sparse(electronicSolver%ELSI_rwHandle, "ELSI_SrealSparse.bin",&
          & self%rowIndLocal, self%colPtrLocal, SnzValLocal)
      call elsi_finalize_rw(electronicSolver%ELSI_rwHandle)
      call cleanShutdown("Finished matrix write")
    end if

    ! Load the matrix into ELSI and solve DM
    call elsi_dm_real_sparse(electronicSolver%elsiHandle, HnzValLocal, SnzValLocal, DMnzValLocal,&
        & Eband(iS))

    ! get DM back into DFTB+ format
    rho(:,:) = 0.0_dp
    call elsi2pack_real(self, self%colStartLocal, self%colEndLocal, iNeighbour,&
        & nNeighbourSK, orb%mOrb, iAtomStart, iSparseStart, img2CentCell, self%colPtrLocal,&
        & DMnzValLocal, self%blockRow, rho(:,iS))

  end subroutine calcDensityRealElsi


  !> Gets energy density matrix using the elsi routine.
  subroutine getEDensityRealElsi(self, electronicSolver, iNeighbour,&
      & nNeighbourSK, iAtomStart, iSparseStart, img2CentCell, orb, erho)

    !> Sparse conversion instance
    type(TSparse2Sparse), intent(inout) :: self

    !> Electronic solver information
    type(TElectronicSolver), intent(inout) :: electronicSolver

    !> Neighbour list for the atoms (First index from 0!)
    integer, intent(in) :: iNeighbour(0:,:)

    !> Nr. of neighbours for the atoms.
    integer, intent(in) :: nNeighbourSK(:)

    !> Atom offset for the squared matrix
    integer, intent(in) :: iAtomStart(:)

    !> indexing array for the sparse Hamiltonian
    integer, intent(in) :: iSparseStart(0:,:)

    !> Mapping between image atoms and corresponding atom in the central cell.
    integer, intent(in) :: img2CentCell(:)

    !> data structure with atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Density matrix in DFTB+ sparse format
    real(dp), intent(out) :: erho(:)

    integer :: iS
    real(dp), allocatable :: EDMnzValLocal(:)

    allocate(EDMnzValLocal(self%nnzLocal))

    ! get the energy weighted density matrix from ELSI
    call elsi_get_edm_real_sparse(electronicSolver%elsiHandle, EDMnzValLocal)

    ! get EDM back into DFTB+ format
    erho(:) = 0.0_dp
    call elsi2pack_real(self, self%colStartLocal, self%colEndLocal, iNeighbour,&
        & nNeighbourSK, orb%mOrb, iAtomStart, iSparseStart, img2CentCell, self%colPtrLocal,&
        & EDMnzValLocal, self%blockRow, erho)

  end subroutine getEDensityRealElsi


  !> Calculates density matrix using the elsi routine.
  subroutine calcDensityComplexElsi(self, parallelKS, electronicSolver, kPoint, kWeight, iCellVec,&
      & cellVec, ham, over, iNeighbour, nNeighbourSK, iAtomStart, iSparseStart, img2CentCell, orb,&
      & rho, Eband)

    !> Sparse conversion instance
    type(TSparse2Sparse), intent(inout) :: self

    !> Contains (iK, iS) tuples to be processed in parallel by various processor groups
    type(TParallelKS), intent(in) :: parallelKS

    !> Electronic solver information
    type(TElectronicSolver), intent(inout) :: electronicSolver

    !> Current k-point
    real(dp), intent(in) :: kPoint(:)

    !> Weight for current k-points
    real(dp), intent(in) :: kWeight

    !> Index for which unit cell atoms are associated with
    integer, intent(in) :: iCellVec(:)

    !> Vectors (in units of the lattice constants) to cells of the lattice
    real(dp), intent(in) :: cellVec(:,:)

    !> hamiltonian in sparse storage
    real(dp), intent(in) :: ham(:,:)

    !> overlap matrix in sparse storage
    real(dp), intent(in) :: over(:)

    !> Neighbour list for the atoms (First index from 0!)
    integer, intent(in) :: iNeighbour(0:,:)

    !> Nr. of neighbours for the atoms.
    integer, intent(in) :: nNeighbourSK(:)

    !> Atom offset for the squared matrix
    integer, intent(in) :: iAtomStart(:)

    !> indexing array for the sparse Hamiltonian
    integer, intent(in) :: iSparseStart(0:,:)

    !> Mapping between image atoms and corresponding atom in the central cell.
    integer, intent(in) :: img2CentCell(:)

    !> data structure with atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Density matrix in DFTB+ sparse format
    real(dp), intent(out) :: rho(:,:)

    !> Band energy
    real(dp), intent(out) :: Eband(:)

    integer :: iS

    complex(dp), allocatable :: HnzValLocal(:), SnzValLocal(:)
    complex(dp), allocatable :: DMnzValLocal(:)
    logical :: tFirstCall

    tFirstCall = .false.
    if (.not. allocated(self%rowIndLocal)) then
      allocate(self%rowIndLocal(self%nnzLocal))
      tFirstCall = .true.
    end if

    allocate(HnzValLocal(self%nnzLocal))
    allocate(SnzValLocal(self%nnzLocal))
    allocate(DMnzValLocal(self%nnzLocal))

    if (tFirstCall) then
      ! also generate rowIndLocal for the new structure
      call pack2elsi_cmplx(self, over, iNeighbour, nNeighbourSK, iAtomStart, iSparseStart,&
          & img2CentCell, kPoint, kWeight, iCellVec, cellVec, self%colStartLocal, self%colEndLocal,&
          & self%colPtrLocal, SnzValLocal, self%rowIndLocal)
      call elsi_set_csc(electronicSolver%elsiHandle, self%nnzGlobal, self%nnzLocal,&
          & self%numColLocal, self%rowIndLocal, self%colPtrLocal)
    else
      call pack2elsi_cmplx(self, over, iNeighbour, nNeighbourSK, iAtomStart, iSparseStart,&
          & img2CentCell, kPoint, kWeight, iCellVec, cellVec, self%colStartLocal, self%colEndLocal,&
          & self%colPtrLocal, SnzValLocal)
    end if

    iS = parallelKS%localKS(2, 1)
    call pack2elsi_cmplx(self, ham(:,iS), iNeighbour, nNeighbourSK, iAtomStart,&
        & iSparseStart, img2CentCell, kPoint, kWeight, iCellVec, cellVec, self%colStartLocal,&
        & self%colEndLocal, self%colPtrLocal, HnzValLocal)

    if (electronicSolver%ELSI_tWriteHS) then
      ! set up for sparse matrix writing
      call elsi_set_rw_csc(electronicSolver%ELSI_rwHandle, self%nnzGlobal, self%nnzLocal,&
          & self%numColLocal)

      call elsi_write_mat_complex_sparse(electronicSolver%ELSI_rwHandle, "ELSI_HcmplxSparse.bin",&
          & self%rowIndLocal, self%colPtrLocal, HnzValLocal)
      call elsi_write_mat_complex_sparse(electronicSolver%ELSI_rwHandle, "ELSI_ScmplxSparse.bin",&
          & self%rowIndLocal, self%colPtrLocal, SnzValLocal)
      call elsi_finalize_rw(electronicSolver%ELSI_rwHandle)
      call cleanShutdown("Finished matrix write")
    end if

    ! Load the matrix into ELSI and solve DM
    call elsi_dm_complex_sparse(electronicSolver%elsiHandle, HnzValLocal, SnzValLocal,&
        & DMnzValLocal, Eband(iS))

    ! get DM back into DFTB+ format
    rho(:,:) = 0.0_dp
    call elsi2pack_cmplx(self, self%colStartLocal, self%colEndLocal, iNeighbour,&
        & nNeighbourSK, orb%mOrb, iAtomStart, iSparseStart, img2CentCell, kPoint, kWeight,&
        & iCellVec, cellVec, self%colPtrLocal, DMnzValLocal, self%blockRow, rho(:,iS))

  end subroutine calcDensityComplexElsi


  !> Gets energy density matrix using the elsi routine.
  subroutine getEDensityComplexElsi(self, electronicSolver, kPoint, kWeight, iCellVec, cellVec,&
      & iNeighbour, nNeighbourSK, iAtomStart, iSparseStart, img2CentCell, orb, erho)

    !> Sparse conversion instance
    type(TSparse2Sparse), intent(inout) :: self

    !> Electronic solver information
    type(TElectronicSolver), intent(inout) :: electronicSolver

    !> Current k-point
    real(dp), intent(in) :: kPoint(:)

    !> Weight for current k-points
    real(dp), intent(in) :: kWeight

    !> Index for which unit cell atoms are associated with
    integer, intent(in) :: iCellVec(:)

    !> Vectors (in units of the lattice constants) to cells of the lattice
    real(dp), intent(in) :: cellVec(:,:)

    !> Neighbour list for the atoms (First index from 0!)
    integer, intent(in) :: iNeighbour(0:,:)

    !> Nr. of neighbours for the atoms.
    integer, intent(in) :: nNeighbourSK(:)

    !> Atom offset for the squared matrix
    integer, intent(in) :: iAtomStart(:)

    !> indexing array for the sparse Hamiltonian
    integer, intent(in) :: iSparseStart(0:,:)

    !> Mapping between image atoms and corresponding atom in the central cell.
    integer, intent(in) :: img2CentCell(:)

    !> data structure with atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Density matrix in DFTB+ sparse format
    real(dp), intent(out) :: erho(:)

    integer :: iS
    complex(dp), allocatable :: EDMnzValLocal(:)

    allocate(EDMnzValLocal(self%nnzLocal))

    ! get the energy weighted density matrix from ELSI
    call elsi_get_edm_complex_sparse(electronicSolver%elsiHandle, EDMnzValLocal)

    ! get EDM back into DFTB+ format
    erho(:) = 0.0_dp
    call elsi2pack_cmplx(self, self%colStartLocal, self%colEndLocal, iNeighbour,&
        & nNeighbourSK, orb%mOrb, iAtomStart, iSparseStart, img2CentCell, kPoint, kWeight,&
        & iCellVec, cellVec, self%colPtrLocal, EDMnzValLocal, self%blockRow, erho)

  end subroutine getEDensityComplexElsi


  !> Creating colptr and nnz for CSC matrix format from packed format
  subroutine pack2colptr_parallel(iNeighbour, nNeighbourSK, iAtomStart, iSparseStart,&
      & img2CentCell, colStartLocal, colEndLocal, nnzLocal, colPtrLocal)

    !> Neighbour list for each atom (first index from 0!).
    integer, intent(in) :: iNeighbour(0:,:)

    !> Nr. of neighbours for each atom (incl. itself).
    integer, intent(in) :: nNeighbourSK(:)

    !> Atom offset for the squared Hamiltonian
    integer, intent(in) :: iAtomStart(:)

    !> Indexing array for the sparse Hamiltonian
    integer, intent(in) :: iSparseStart(0:,:)

    !> Atomic mapping indexes
    integer, intent(in) :: img2CentCell(:)

    !> Column of global matrix where local matrix starts
    integer, intent(in) :: colStartLocal

    !> Column of global matrix where local matrix ends
    integer, intent(in) :: colEndLocal

    !> Local number of  non-zero elements
    integer, intent(out) :: nnzLocal

    !> Local column pointer
    integer, intent(out) :: colPtrLocal(:)

    integer :: nAtom
    integer :: iOrig, ii, jj, nOrb1, nOrb2
    integer :: iNeigh
    integer :: iAtom1, iAtom2, iAtom2f, kk

    logical, allocatable :: blockList(:)

    nAtom = size(iNeighbour, dim=2)

    colPtrLocal(:) = 0
    nnzLocal = 0

    allocate(blockList(nAtom))

    ! Loop over all atom blocks
    do iAtom1 = 1, nAtom
      ii = iAtomStart(iAtom1)
      nOrb1 = iAtomStart(iAtom1+1) - ii
      blockList(:) = .false.
      do iNeigh = 0, nNeighbourSK(iAtom1)
        iOrig = iSparseStart(iNeigh,iAtom1) + 1
        iAtom2 = iNeighbour(iNeigh, iAtom1)
        iAtom2f = img2CentCell(iAtom2)
        jj = iAtomStart(iAtom2f)
        nOrb2 = iAtomStart(iAtom2f+1) - jj

        if (blockList(iAtom2f)) then
          cycle
        else
          blockList(iAtom2f) = .true.
        end if

        if (isBlockInLocal(jj, jj+nOrb2-1, ii, ii+nOrb1-1, colStartLocal, colEndLocal)) then
          do kk = ii, ii + nOrb1 - 1
            if (isColumnInLocal(kk, colStartLocal, colEndLocal)) then
              nnzLocal = nnzLocal + nOrb2
              colPtrLocal(kk - colStartLocal + 2) = colPtrLocal(kk - colStartLocal + 2) + nOrb2
            end if
          end do
        end if

        if (ii == jj) then
          ! on the diagonal, can not be in other triangle
          cycle
        end if

        do kk = jj, jj + nOrb2 - 1
          if (isColumnInLocal(kk, colStartLocal, colEndLocal)) then
            nnzLocal = nnzLocal + nOrb1
            colPtrLocal(kk -colStartLocal + 2) = colPtrLocal(kk - colStartLocal + 2) + nOrb1
          end if
        end do
      end do
    end do
    colPtrLocal(1) = 1
    do ii = 2, size(colPtrLocal)
      colPtrLocal(ii) = colPtrLocal(ii-1) + colPtrLocal(ii)
    end do
    colPtrLocal(size(colPtrLocal)) = nnzLocal + 1

  end subroutine pack2colptr_parallel


  !> Convert sparse DFTB+ matrix to distributed CSC matrix format for ELSI calculations for real
  !> matrices
  !>
  !> NOTE: ELSI needs the full matrix (both triangles)
  subroutine pack2elsi_real(self, orig, iNeighbour, nNeighbourSK, iAtomStart, iSparseStart,&
      & img2CentCell, colStartLocal, colEndLocal, colPtrLocal, nzValLocal, rowIndLocal)

    !> Sparse conversion instance
    type(TSparse2Sparse), intent(in) :: self

    !> Sparse Hamiltonian
    real(dp), intent(in) :: orig(:)

    !> Neighbour list for each atom (first index from 0!).
    integer, intent(in) :: iNeighbour(0:,:)

    !> Nr. of neighbours for each atom (incl. itself).
    integer, intent(in) :: nNeighbourSK(:)

    !> Atom offset for the squared Hamiltonian
    integer, intent(in) :: iAtomStart(:)

    !> Indexing array for the sparse Hamiltonian
    integer, intent(in) :: iSparseStart(0:,:)

    !> Atomic mapping indexes.
    integer, intent(in) :: img2CentCell(:)

    !> Column of global matrix where local matrix starts
    integer, intent(in) :: colStartLocal

    !> Column of global matrix where local matrix ends
    integer, intent(in) :: colEndLocal

    !> Local column pointer
    integer, intent(in) :: colPtrLocal(:)

    !> Local non-zero elements
    real(dp), intent(out) :: nzValLocal(:)

    !> Local row index pointer
    integer, intent(out), optional :: rowIndLocal(:)

    integer :: nAtom
    integer :: iOrig, ii, jj, nOrb1, nOrb2
    integer :: iNeigh
    integer :: iAt, iAtom1, iAtom2, iAtom2f

    integer :: iNext
    integer, allocatable :: blockList(:,:)
    logical, allocatable :: tRowTrans(:)

    nAtom = size(iNeighbour, dim=2)

    @:ASSERT(nAtom > 0)
    @:ASSERT(size(nNeighbourSK) == nAtom)
    @:ASSERT(size(iAtomStart) == nAtom + 1)

    allocate(blockList(nAtom,2))
    allocate(tRowTrans(nAtom))
    if (present(rowIndLocal)) then
      rowIndLocal(:) = 0
    end if
    nzValLocal(:) = 0.0_dp

    ! Offset in column belonging to transposed triangle
    blockList(:,2) = 1

    ! loop over atoms relevant to this processor
    do iAt = 1, self%nAtomsInColumns
      iAtom1 = self%atomsInColumns(iAt)
      ii = iAtomStart(iAtom1)
      nOrb1 = iAtomStart(iAtom1+1) - ii
      ! Offset in current column
      blockList(:,1) = 0
      tRowTrans = .false.
      ! Starting index for column in DFTB+ sparse structure, because column probaly already contains
      ! blocks coming from transposing previously processed elements.
      iNext = blockList(iAtom1, 2)
      do iNeigh = 0, nNeighbourSK(iAtom1)
        iOrig = iSparseStart(iNeigh,iAtom1) + 1
        iAtom2 = iNeighbour(iNeigh, iAtom1)
        iAtom2f = img2CentCell(iAtom2)

        jj = iAtomStart(iAtom2f)
        @:ASSERT(jj >= ii)
        nOrb2 = iAtomStart(iAtom2f+1) - jj

        if (blockList(iAtom2f,1) == 0) then
          blockList(iAtom2f,1) = iNext
          iNext = iNext + nOrb2
        end if

        if ( .not. isBlockInLocal(jj,jj+nOrb2-1, ii, ii+nOrb1-1, colStartLocal, colEndLocal)) then
          cycle
        end if
        call addBlock2Elsi(reshape(orig(iOrig:iOrig+nOrb1*nOrb2-1), [ nOrb2, nOrb1 ]),&
            & colStartLocal, colEndLocal, jj, ii, colPtrLocal, blockList(iAtom2f,1)-1, nzValLocal,&
            & rowIndLocal)

        if (ii == jj) then
          cycle
        end if

        ! Because of folding of periodic images, it can happen that the transposed block has already
        ! been registered.
        if (.not. tRowTrans(iAtom2f)) then
          blockList(iAtom2f,2) = blockList(iAtom2f,2) + nOrb1
          tRowTrans(iAtom2f) = .true.
        end if

        call addBlock2Elsi(transpose(reshape(orig(iOrig:iOrig+nOrb1*nOrb2-1), [ nOrb2, nOrb1 ])),&
            & colStartLocal, colEndLocal, ii, jj, colPtrLocal, blockList(iAtom2f,2)-nOrb1-1,&
            & nzValLocal, rowIndLocal)
      end do
    end do

  end subroutine pack2elsi_real


  !> Convert sparse DFTB+ matrix to distributed CSC matrix format for ELSI calculations for complex
  !> matrices
  !>
  !> NOTE: ELSI needs the full matrix (both triangles)
  subroutine pack2elsi_cmplx(self, orig, iNeighbour, nNeighbourSK, iAtomStart,&
      & iSparseStart, img2CentCell, kPoint, kWeight, iCellVec, cellVec, colStartLocal, colEndLocal,&
      & colPtrLocal, nzValLocal, rowIndLocal)

    !> Sparse conversion instance
    type(TSparse2Sparse), intent(in) :: self

    !> Sparse Hamiltonian
    real(dp), intent(in) :: orig(:)

    !> Neighbour list for each atom (first index from 0!).
    integer, intent(in) :: iNeighbour(0:,:)

    !> Nr. of neighbours for each atom (incl. itself).
    integer, intent(in) :: nNeighbourSK(:)

    !> Atom offset for the squared Hamiltonian
    integer, intent(in) :: iAtomStart(:)

    !> Indexing array for the sparse Hamiltonian
    integer, intent(in) :: iSparseStart(0:,:)

    !> Atomic mapping indexes.
    integer, intent(in) :: img2CentCell(:)

    !> Current k-point
    real(dp), intent(in) :: kPoint(:)

    !> Weight for current k-points
    real(dp), intent(in) :: kWeight

    !> Index for which unit cell atoms are associated with
    integer, intent(in) :: iCellVec(:)

    !> Vectors (in units of the lattice constants) to cells of the lattice
    real(dp), intent(in) :: cellVec(:,:)

    !> Column of global matrix where local matrix starts
    integer, intent(in) :: colStartLocal

    !> Column of global matrix where local matrix ends
    integer, intent(in) :: colEndLocal

    !> Local column pointer
    integer, intent(in) :: colPtrLocal(:)

    !> Local non-zero elements
    complex(dp), intent(out) :: nzValLocal(:)

    !> Local row index pointer
    integer, intent(out), optional :: rowIndLocal(:)

    integer :: nAtom
    integer :: iOrig, ii, jj, nOrb1, nOrb2
    integer :: iNeigh
    integer :: iAt, iAtom1, iAtom2, iAtom2f

    integer :: iNext, iVec
    integer, allocatable :: blockList(:,:)
    logical, allocatable :: tRowTrans(:)
    real(dp) :: kPoint2p(3)
    complex(dp) :: phase

    kPoint2p(:) = 2.0_dp * pi * kPoint(:)
    nAtom = size(iNeighbour, dim=2)

    @:ASSERT(nAtom > 0)
    @:ASSERT(size(nNeighbourSK) == nAtom)
    @:ASSERT(size(iAtomStart) == nAtom + 1)

    allocate(blockList(nAtom,2))
    allocate(tRowTrans(nAtom))
    if (present(rowIndLocal)) then
      rowIndLocal(:) = 0
    end if
    nzValLocal(:) = cmplx(0,0,dp)

    ! Offset in column belonging to transposed triangle
    blockList(:,2) = 1

    ! loop over atoms relevant to this processor
    do iAt = 1, self%nAtomsInColumns
      iAtom1 = self%atomsInColumns(iAt)
      ii = iAtomStart(iAtom1)
      nOrb1 = iAtomStart(iAtom1+1) - ii
      ! Offset in current column
      blockList(:,1) = 0
      tRowTrans = .false.
      ! Starting index for column in DFTB+ sparse structure, because column probaly already contains
      ! blocks coming from transposing previously processed elements.
      iNext = blockList(iAtom1, 2)
      do iNeigh = 0, nNeighbourSK(iAtom1)
        iOrig = iSparseStart(iNeigh,iAtom1) + 1
        iAtom2 = iNeighbour(iNeigh, iAtom1)
        iAtom2f = img2CentCell(iAtom2)

        jj = iAtomStart(iAtom2f)
        @:ASSERT(jj >= ii)
        nOrb2 = iAtomStart(iAtom2f+1) - jj

        if (blockList(iAtom2f,1) == 0) then
          blockList(iAtom2f,1) = iNext
          iNext = iNext + nOrb2
        end if

        if ( .not. isBlockInLocal(jj,jj+nOrb2-1, ii, ii+nOrb1-1, colStartLocal, colEndLocal)) then
          cycle
        end if

        iVec = iCellVec(iAtom2)
        phase = exp(cmplx(0, 1, dp) * dot_product(kPoint2p, cellVec(:, iVec)))

        call addBlock2Elsi(phase*reshape(orig(iOrig:iOrig+nOrb1*nOrb2-1), [ nOrb2, nOrb1 ]),&
            & colStartLocal, colEndLocal, jj, ii, colPtrLocal, blockList(iAtom2f,1)-1, nzValLocal,&
            & rowIndLocal)

        if (ii == jj) then
          cycle
        end if

        ! other triangle, so Hermitian symmetry
        phase = conjg(phase)

        ! Because of folding of periodic images, it can happen that the transposed block has already
        ! been registered.
        if (.not. tRowTrans(iAtom2f)) then
          blockList(iAtom2f,2) = blockList(iAtom2f,2) + nOrb1
          tRowTrans(iAtom2f) = .true.
        end if

        call addBlock2Elsi(&
            & phase * transpose(reshape(orig(iOrig:iOrig+nOrb1*nOrb2-1), [ nOrb2, nOrb1 ])),&
            & colStartLocal, colEndLocal, ii, jj, colPtrLocal, blockList(iAtom2f,2)-nOrb1-1,&
            & nzValLocal, rowIndLocal)
      end do
    end do

  end subroutine pack2elsi_cmplx


  !> Checks if atom block is part of local matrix (Elsi)
  pure logical function isBlockInLocal(rowStartBlock, rowEndBlock, colStartBlock, colEndBlock,&
      & colStartLocal, colEndLocal)

    !> Row of global matrix where block starts
    integer, intent(in) :: rowStartBlock

    !> Row of global matrix where block ends
    integer, intent(in) :: rowEndBlock

    !> Column of global matrix where block starts
    integer, intent(in) :: colStartBlock

    !> Column of global matrix where block ends
    integer, intent(in) :: colEndBlock

    !> Column of global matrix where local part starts
    integer, intent(in) :: colStartLocal

    !> Column of global matrix where local part ends
    integer, intent(in) :: colEndLocal

    isBlockInLocal = .false.
    if ( (colStartLocal <= colStartBlock) .and. (colStartBlock <= colEndLocal) ) then
      isBlockInLocal = .true.
    else if ( (colStartLocal <= colEndBlock) .and. (colEndBlock <= colEndLocal) ) then
      isBlockInLocal = .true.
    else if ( (colStartBlock <= colStartLocal) .and. (colStartLocal <= colEndBlock)) then
      isBlockInLocal = .true.
    else if ( (colStartBlock <= colEndLocal) .and. (colEndLocal <= colEndBlock)) then
      isBlockInLocal = .true.
    else if ( (colStartLocal <= rowStartBlock) .and. (rowStartBlock <= colEndLocal) ) then
      isBlockInLocal = .true.
    else if ( (colStartLocal <= rowEndBlock) .and. (rowEndBlock <= colEndLocal) ) then
      isBlockInLocal = .true.
    else if ( (rowStartBlock <= colStartLocal) .and. (colStartLocal <= rowEndBlock)) then
      isBlockInLocal = .true.
    else if ( (rowStartBlock <= colEndLocal) .and. (colEndLocal <= rowEndBlock)) then
      isBlockInLocal = .true.
    end if

  end function isBlockInLocal


  !> Checks whether global column is in local matrix
  pure logical function isColumnInLocal(col, colStartLocal, colEndLocal)

    !> global column
    integer, intent(in) :: col

    !> Column of global matrix where local matrix starts
    integer, intent(in) :: colStartLocal

    !> Column of global matrix where local matrix ends
    integer, intent(in) :: colEndLocal

    if ( (colStartLocal <= col) .and. (col <= colEndLocal) ) then
      isColumnInLocal = .true.
    else
      isColumnInLocal = .false.
    end if

  end function isColumnInLocal

#:for SUFFIX in FLAVOURS
  !> Add the content of a local matrix block to ELSI CSC format
  subroutine addBlock2Elsi${SUFFIX}$(loc, colStart, colEnd, ii, jj, colptr, rowOffset, val,&
      & rowIndLocal)

    !> Local matrix.
    ${SUFFIX}$(dp), intent(in) :: loc(:,:)

    !> Column of global matrix where local matrix starts
    integer, intent(in) :: colStart

    !> Column of global matrix where local matrix ends
    integer, intent(in) :: colEnd

    !> Starting row in the global matrix.
    integer, intent(in) :: ii

    !> Starting column in the global matrix
    integer, intent(in) :: jj

    !> column pointer
    integer, intent(in) :: colptr(:)

    !> index of the next element per column
    integer, intent(in) :: rowOffset

    !> values in CSC format
    ${SUFFIX}$(dp), intent(inout) :: val(:)

    !> row index pointer
    integer, intent(inout), optional :: rowIndLocal(:)

    integer :: j2, iloc, jloc
    integer :: jStart, jEnd

    jStart = max(jj, colStart) - colStart + 1
    jEnd = min(jj+size(loc,dim=2)-1, colEnd) - colStart + 1
    jloc = max(jj, colStart) - jj + 1

    if (present(rowIndLocal)) then
      do j2 = jStart, jEnd
        do iloc = 1, size(loc,1)
          val(colptr(j2)+rowOffset+iloc-1) = val(colptr(j2) + rowOffset+iloc-1) + loc(iloc,jloc)
          rowIndLocal(colptr(j2) + rowOffset + iloc-1) = iloc + ii - 1
        end do
        jloc = jloc + 1
      end do
    else
      do j2 = jStart, jEnd
        do iloc = 1, size(loc,1)
          val(colptr(j2)+rowOffset+iloc-1) = val(colptr(j2) + rowOffset+iloc-1) + loc(iloc,jloc)
        end do
        jloc = jloc + 1
      end do
    end if

  end subroutine addBlock2Elsi${SUFFIX}$
#:endfor

  !> Convert CSC matrix format into DFTB+ sparse format
  !>
  !> Note: primitive will not be set to zero on startup, and values are added to enable addition of
  !> spin components. Make sure, you set it to zero before invoking this routine the first time.
  subroutine elsi2pack_real(self, colStart, colEnd, iNeighbour, nNeighbourSK, mOrb,&
      & iAtomStart, iSparseStart, img2CentCell, colptr, nzval, blockRow, primitive)

    !> Sparse conversion instance
    type(TSparse2Sparse), intent(in) :: self

    !> Column of global matrix where local matrix starts
    integer, intent(in) :: colStart

    !> Column of global matrix where local matrix ends
    integer, intent(in) :: colEnd

    !> Neighbour list for each atom (first index from 0!).
    integer, intent(in) :: iNeighbour(0:,:)

    !> Nr. of neighbours for each atom (incl. itself).
    integer, intent(in) :: nNeighbourSK(:)

    !> Maximal number of orbitals on an atom.
    integer, intent(in) :: mOrb

    !> Atom offset for the squared Hamiltonian
    integer, intent(in) :: iAtomStart(:)

    !> Indexing array for the sparse Hamiltonian
    integer, intent(in) :: iSparseStart(0:,:)

    !> Atomic mapping indexes.
    integer, intent(in) :: img2CentCell(:)

    !> Local column pointer
    integer, intent(in) :: colptr(:)

    !> Local non-zero elements
    real(dp), intent(in) :: nzval(:)

    !> Saves starting row of blocks in nzValLocal
    integer, intent(in) :: blockRow(0:,:)

    !> Sparse Hamiltonian
    real(dp), intent(inout) :: primitive(:)

    integer :: nAtom
    integer :: iOrig, ii, jj, kk
    integer :: iNeigh
    integer :: iAt, iAtom1, iAtom2, iAtom2f
    integer :: nOrb1, nOrb2
    real(dp) :: tmpSqr(mOrb,mOrb)

    nAtom = size(iNeighbour, dim=2)

    tmpSqr(:,:) = 0.0_dp

    ! loop over relevant atoms to pack back
    do iAt = 1, self%nAtomsInColumns
      iAtom1 = self%atomsInColumns(iAt)
      ii = iAtomStart(iAtom1)
      nOrb1 = iAtomStart(iAtom1+1) - ii
      do iNeigh = 0, nNeighbourSK(iAtom1)
        iOrig = iSparseStart(iNeigh,iAtom1) + 1
        iAtom2 = iNeighbour(iNeigh, iAtom1)
        iAtom2f = img2CentCell(iAtom2)
        jj = iAtomStart(iAtom2f)
        nOrb2 = iAtomStart(iAtom2f+1) - jj

        if ( .not. isBlockInLocal(jj,jj+nOrb2-1, ii, ii+nOrb1-1, colStart, colEnd)) then
          cycle
        end if

        call cpElsi2Block(colStart, colEnd, colptr, nzval, ii, blockRow(iNeigh, iAtom1),&
            & tmpSqr(1:nOrb2,1:nOrb1))

        ! Symmetrize the on-site block before packing, just in case
        if (iAtom1 == iAtom2f) then
          do kk = 1, nOrb2
            tmpSqr(kk, kk+1:nOrb1) = tmpSqr(kk+1:nOrb1, kk)
          end do
        end if

        primitive(iOrig : iOrig + nOrb1 * nOrb2 - 1) = primitive(iOrig : iOrig + nOrb1 * nOrb2 - 1)&
            & + reshape(tmpSqr(1:nOrb2,1:nOrb1), [ nOrb1*nOrb2 ])

      end do
    end do

  end subroutine elsi2pack_real


  !> Convert CSC matrix format into DFTB+ sparse format
  !>
  !> Note: primitive will not be set to zero on startup, and values are added to enable addition of
  !> spin components. Make sure, you set it to zero before invoking this routine the first time.
  subroutine elsi2pack_cmplx(self, colStart, colEnd, iNeighbour, nNeighbourSK, mOrb,&
      & iAtomStart, iSparseStart, img2CentCell, kPoint, kWeight, iCellVec, cellVec, colptr, nzval,&
      & blockRow, primitive)

    !> Sparse conversion instance
    type(TSparse2Sparse), intent(in) :: self

    !> Column of global matrix where local matrix starts
    integer, intent(in) :: colStart

    !> Column of global matrix where local matrix ends
    integer, intent(in) :: colEnd

    !> Neighbour list for each atom (first index from 0!).
    integer, intent(in) :: iNeighbour(0:,:)

    !> Nr. of neighbours for each atom (incl. itself).
    integer, intent(in) :: nNeighbourSK(:)

    !> Maximal number of orbitals on an atom.
    integer, intent(in) :: mOrb

    !> Atom offset for the squared Hamiltonian
    integer, intent(in) :: iAtomStart(:)

    !> Indexing array for the sparse Hamiltonian
    integer, intent(in) :: iSparseStart(0:,:)

    !> Atomic mapping indexes.
    integer, intent(in) :: img2CentCell(:)

    !> Current k-point
    real(dp), intent(in) :: kPoint(:)

    !> Weight for current k-points
    real(dp), intent(in) :: kWeight

    !> Index for which unit cell atoms are associated with
    integer, intent(in) :: iCellVec(:)

    !> Vectors (in units of the lattice constants) to cells of the lattice
    real(dp), intent(in) :: cellVec(:,:)

    !> Local column pointer
    integer, intent(in) :: colptr(:)

    !> Local non-zero elements
    complex(dp), intent(in) :: nzval(:)

    !> Saves starting row of blocks in nzValLocal
    integer, intent(in) :: blockRow(0:,:)

    !> Sparse Hamiltonian
    real(dp), intent(inout) :: primitive(:)

    integer :: nAtom, iVec
    integer :: iOrig, ii, jj, kk
    integer :: iNeigh
    integer :: iAt, iAtom1, iAtom2, iAtom2f
    integer :: nOrb1, nOrb2
    complex(dp) :: tmpSqr(mOrb,mOrb)
    real(dp) :: kPoint2p(3)
    complex(dp) :: phase

    kPoint2p(:) = 2.0_dp * pi * kPoint(:)
    nAtom = size(iNeighbour, dim=2)

    tmpSqr(:,:) = cmplx(0,0,dp)

    ! loop over relevant atoms to pack back
    do iAt = 1, self%nAtomsInColumns
      iAtom1 = self%atomsInColumns(iAt)
      ii = iAtomStart(iAtom1)
      nOrb1 = iAtomStart(iAtom1+1) - ii
      do iNeigh = 0, nNeighbourSK(iAtom1)
        iOrig = iSparseStart(iNeigh,iAtom1) + 1
        iAtom2 = iNeighbour(iNeigh, iAtom1)
        iAtom2f = img2CentCell(iAtom2)
        jj = iAtomStart(iAtom2f)
        nOrb2 = iAtomStart(iAtom2f+1) - jj

        if ( .not. isBlockInLocal(jj,jj+nOrb2-1, ii, ii+nOrb1-1, colStart, colEnd)) then
          cycle
        end if

        call cpElsi2Block(colStart, colEnd, colptr, nzval, ii, blockRow(iNeigh, iAtom1),&
            & tmpSqr(1:nOrb2,1:nOrb1))

        iVec = iCellVec(iAtom2)
        phase = exp(cmplx(0, -1, dp) * dot_product(kPoint2p, cellVec(:, iVec)))

        tmpSqr(1:nOrb2,1:nOrb1) = phase * tmpSqr(1:nOrb2,1:nOrb1)

        ! Hermitian conjugate the on-site block before packing, just in case
        if (iAtom1 == iAtom2f) then
          do kk = 1, nOrb2
            tmpSqr(kk, kk+1:nOrb1) = conjg(tmpSqr(kk+1:nOrb1, kk))
          end do
        end if

        primitive(iOrig : iOrig + nOrb1 * nOrb2 - 1) = primitive(iOrig : iOrig + nOrb1 * nOrb2 - 1)&
            & + kWeight * real(reshape(tmpSqr(1:nOrb2,1:nOrb1), [ nOrb1*nOrb2 ]))

      end do
    end do

  end subroutine elsi2pack_cmplx


#:for SUFFIX in FLAVOURS
  !> Copies the content from the ELSI structure to block
  subroutine cpElsi2Block${SUFFIX}$(colStart, colEnd, colptr, nzval, jj, blockRow, loc)

    !> Column of global matrix where local matrix starts
    integer, intent(in) :: colStart

    !> Column of global matrix where local matrix ends
    integer, intent(in) :: colEnd

    !> column pointer
    integer, intent(in) :: colptr(:)

    !> non-zero values
    ${SUFFIX}$(dp), intent(in) :: nzval(:)

    !> Starting column in the global matrix
    integer, intent(in) :: jj

    !> Saves starting row of blocks in nzValLocal
    integer, intent(in) :: blockRow

    !> Local block of matrix.
    ${SUFFIX}$(dp), intent(out) :: loc(:,:)

    integer :: j2, iloc

    loc(:,:) = 0.0_dp

    do j2 = 1, size(loc, dim=2)
      if ( isColumnInLocal(jj + j2 - 1, colStart, colEnd )) then
        iloc = blockRow + colptr(jj-colStart+j2) - 1
        loc(:, j2) = nzval(iloc:iloc+size(loc,dim=1)-1)
      end if
    end do

  end subroutine cpElsi2Block${SUFFIX}$
#:endfor

#:endif


end module sparse2sparse
